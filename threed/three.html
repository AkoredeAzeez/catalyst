<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Three.js 360Â° Virtual Tour (Hotspots + Crossfade)</title>
  <style>
    html, body { height: 100%; margin: 0; overflow: hidden; background: #0b0b0c; }
    #app { position: fixed; inset: 0; }
    canvas { display: block; }

    /* Minimal UI */
    .hud { position: fixed; left: 12px; bottom: 12px; color: #e6e6e6; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, "Apple Color Emoji", "Segoe UI Emoji"; }
    .hud .pill { display: inline-block; padding: 8px 12px; border-radius: 999px; background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.12); backdrop-filter: blur(6px); }
    .hud .scene { font-weight: 600; }
    .hud .help { margin-top: 6px; font-size: 12px; opacity: .8; }

    .topright { position: fixed; right: 12px; top: 12px; display: flex; gap: 8px; }
    .btn { padding: 8px 12px; border-radius: 10px; border: 1px solid rgba(255,255,255,.14); color: #e6e6e6; background: rgba(255,255,255,.06); cursor: pointer; }
    .btn:hover { background: rgba(255,255,255,.10); }

    /* Pointer cue when hovering hotspots */
    .hotspot-hover { cursor: pointer !important; }
  </style>
</head>
<body>
  <div id="app"></div>
  <div class="topright">
    <button class="btn" id="resetView">Reset View</button>
    <button class="btn" id="toggleLabels">Toggle Labels</button>
  </div>
  <div class="hud">
    <div class="pill"><span>Room:</span> <span class="scene" id="sceneName">â€”</span></div>
    <div class="help">Drag to look â€¢ Click hotspot to move â€¢ Pinch/scroll to zoom</div>
  </div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // ==========================
    // 1) CONFIGURE YOUR TOUR ðŸ‘‡
    // ==========================
    const SCENES = {
      living: {
        name: 'Living Room',
        image: './assets/img1.jpg',
        hotspots: [
          { id: 'toKitchen', label: 'Go to Kitchen', yaw: 35, pitch: -2, target: 'kitchen' },
          { id: 'toHall',    label: 'To Hallway',    yaw: -120, pitch: -3, target: 'hall' },
        ],
      },
      kitchen: {
        name: 'Kitchen',
        image: './assets/img2.jpg',
        hotspots: [
          { id: 'toLiving',  label: 'Back to Living', yaw: -145, pitch: -1, target: 'living' },
          { id: 'toDining',  label: 'Dining',         yaw: 10, pitch: -2,  target: 'dining' },
        ],
      },
      hall: {
        name: 'Hallway',
        image: './assets/img3.jpg',
        hotspots: [
          { id: 'toLiving', label: 'Living', yaw: 60, pitch: 0, target: 'living' },
          { id: 'toBedroom', label: 'Bedroom', yaw: -30, pitch: -4, target: 'bedroom' },
        ],
      },
      dining: {
        name: 'Dining',
        image: './assets/img4.jpg',
        hotspots: [
          { id: 'toKitchen', label: 'Kitchen', yaw: -170, pitch: -2, target: 'kitchen' },
        ],
      },
      bedroom: {
        name: 'Bedroom',
        image: './assets/img5.jpg',
        hotspots: [
          { id: 'toHall', label: 'Hall', yaw: 140, pitch: -3, target: 'hall' },
        ],
      },
    };

    const START_SCENE_KEY = 'living';

    // ==============
    // 2) BOILERPLATE
    // ==============
    const app = document.querySelector('#app');
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 2000);
    camera.position.set(0, 0, 0.1);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    app.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enablePan = false;
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.rotateSpeed = 0.22;
    controls.enableZoom = true;
    controls.zoomSpeed = 0.5;
    controls.minDistance = 0.1;
    controls.maxDistance = 1.5;
    controls.minPolarAngle = THREE.MathUtils.degToRad(2);
    controls.maxPolarAngle = THREE.MathUtils.degToRad(178);

    scene.add(new THREE.AmbientLight(0xffffff, 0.4));

    const SPHERE_RADIUS = 50;
    const sphereGeo = new THREE.SphereGeometry(SPHERE_RADIUS, 64, 64);

    const matA = new THREE.MeshBasicMaterial({ side: THREE.BackSide, transparent: true, opacity: 1 });
    const matB = new THREE.MeshBasicMaterial({ side: THREE.BackSide, transparent: true, opacity: 0 });

    const sphereA = new THREE.Mesh(sphereGeo, matA);
    const sphereB = new THREE.Mesh(sphereGeo, matB);
    scene.add(sphereA, sphereB);

    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();

    const hotspotGroup = new THREE.Group();
    scene.add(hotspotGroup);

    let labelsVisible = true;

    const textureLoader = new THREE.TextureLoader();
    const textureCache = new Map();

    function loadTexture(url) {
      return new Promise((resolve, reject) => {
        if (textureCache.has(url)) return resolve(textureCache.get(url));
        textureLoader.load(
          url,
          tex => {
            tex.colorSpace = THREE.SRGBColorSpace;
            tex.minFilter = THREE.LinearFilter;
            textureCache.set(url, tex);
            resolve(tex);
          },
          undefined,
          err => reject(err)
        );
      });
    }

    function yawPitchToVec3(yawDeg, pitchDeg, radius = SPHERE_RADIUS - 0.2) {
      const yaw = THREE.MathUtils.degToRad(yawDeg);
      const pitch = THREE.MathUtils.degToRad(pitchDeg);
      const x = Math.sin(yaw) * Math.cos(pitch) * radius;
      const y = Math.sin(pitch) * radius;
      const z = -Math.cos(yaw) * Math.cos(pitch) * radius;
      return new THREE.Vector3(x, y, z);
    }

    function makeHotspot(labelText = '') {
      const group = new THREE.Group();

      const dotMat = new THREE.SpriteMaterial({ map: makeCircleTexture(), depthTest: true, depthWrite: false, opacity: 0.95 });
      const dot = new THREE.Sprite(dotMat);
      dot.scale.set(1.2, 1.2, 1.2);
      group.add(dot);

      const label = new THREE.Mesh(
        new THREE.PlaneGeometry(4, 1.2),
        new THREE.MeshBasicMaterial({ map: makeLabelTexture(labelText), transparent: true })
      );
      label.position.set(0, -2.2, 0);
      label.renderOrder = 999;
      group.add(label);

      group.userData = { isHotspot: true, labelMesh: label };
      return group;
    }

    function makeCircleTexture() {
      const s = 128;
      const c = document.createElement('canvas');
      c.width = c.height = s;
      const ctx = c.getContext('2d');
      ctx.clearRect(0, 0, s, s);
      ctx.beginPath();
      ctx.arc(s/2, s/2, s*0.34, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(255,255,255,0.92)';
      ctx.fill();
      ctx.lineWidth = 4;
      ctx.strokeStyle = 'rgba(80,160,255,0.9)';
      ctx.stroke();
      const tex = new THREE.CanvasTexture(c);
      tex.colorSpace = THREE.SRGBColorSpace;
      return tex;
    }

    function makeLabelTexture(text) {
      const padX = 24, padY = 12;
      const font = '500 32px system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial';
      const c = document.createElement('canvas');
      const ctx = c.getContext('2d');
      ctx.font = font;
      const metrics = ctx.measureText(text);
      const w = Math.ceil(metrics.width) + padX * 2;
      const h = 48 + padY * 2;
      c.width = w; c.height = h;
      ctx.font = font;
      ctx.fillStyle = 'rgba(20,20,24,0.7)';
      roundRect(ctx, 0, 0, w, h, 18);
      ctx.fill();
      ctx.strokeStyle = 'rgba(255,255,255,0.18)';
      ctx.lineWidth = 2; ctx.stroke();
      ctx.fillStyle = '#eaeaea';
      ctx.textBaseline = 'middle';
      ctx.fillText(text, padX, h/2);
      const tex = new THREE.CanvasTexture(c);
      tex.colorSpace = THREE.SRGBColorSpace;
      tex.generateMipmaps = false;
      return tex;
    }

    function roundRect(ctx, x, y, w, h, r) {
      ctx.beginPath();
      ctx.moveTo(x+r, y);
      ctx.arcTo(x+w, y, x+w, y+h, r);
      ctx.arcTo(x+w, y+h, x, y+h, r);
      ctx.arcTo(x, y+h, x, y, r);
      ctx.arcTo(x, y, x+w, y, r);
      ctx.closePath();
    }

    function buildHotspots(sceneKey) {
      hotspotGroup.clear();
      const def = SCENES[sceneKey];
      if (!def?.hotspots) return;
      for (const h of def.hotspots) {
        const hs = makeHotspot(h.label);
        const pos = yawPitchToVec3(h.yaw, h.pitch);
        hs.position.copy(pos);
        hs.lookAt(0, 0, 0);
        hs.userData.target = h.target;
        hs.userData.labelText = h.label;
        hotspotGroup.add(hs);
      }
      setLabelsVisible(labelsVisible);
    }

    function setLabelsVisible(on) {
      hotspotGroup.traverse(obj => {
        if (obj.isMesh && obj.userData && obj.parent?.userData?.isHotspot) {
          obj.visible = on;
        }
      });
    }

    const sceneNameEl = document.getElementById('sceneName');
    function setSceneName(name) { sceneNameEl.textContent = name || 'â€”'; }

    let activeOnA = true;
    let isFading = false;
    async function switchScene(sceneKey, options = { fadeMs: 600 }) {
      const def = SCENES[sceneKey];
      if (!def) return;
      try {
        const tex = await loadTexture(def.image);
        setSceneName(def.name);
        buildHotspots(sceneKey);

        if (activeOnA) {
          matB.map = tex; matB.needsUpdate = true;
        } else {
          matA.map = tex; matA.needsUpdate = true;
        }

        isFading = true;
        const t0 = performance.now();
        const dur = options.fadeMs ?? 600;
        function step(now) {
          const k = Math.min(1, (now - t0) / dur);
          if (activeOnA) { matA.opacity = 1 - k; matB.opacity = k; }
          else            { matA.opacity = k;     matB.opacity = 1 - k; }
          if (k < 1) requestAnimationFrame(step);
          else {
            activeOnA = !activeOnA;
            if (activeOnA) { matB.opacity = 0; }
            else           { matA.opacity = 0; }
            isFading = false;
          }
        }
        requestAnimationFrame(step);
      } catch (e) {
        console.error('Failed to load texture', e);
      }
    }

    function updateHoverCursor(clientX, clientY) {
      pointer.x =  (clientX / window.innerWidth) * 2 - 1;
      pointer.y = -(clientY / window.innerHeight) * 2 + 1;
      raycaster.setFromCamera(pointer, camera);
      const hits = raycaster.intersectObjects(hotspotGroup.children, true);
      if (hits.some(h => h.object?.parent?.userData?.isHotspot)) {
        renderer.domElement.classList.add('hotspot-hover');
      } else {
        renderer.domElement.classList.remove('hotspot-hover');
      }
    }

    function handleSelect(clientX, clientY) {
      if (isFading) return;
      pointer.x =  (clientX / window.innerWidth) * 2 - 1;
      pointer.y = -(clientY / window.innerHeight) * 2 + 1;
      raycaster.setFromCamera(pointer, camera);
      const hits = raycaster.intersectObjects(hotspotGroup.children, true);
      const hit = hits.find(h => h.object?.parent?.userData?.isHotspot);
      if (hit) {
        const group = hit.object.parent;
        const targetKey = group.userData.target;
        if (targetKey && SCENES[targetKey]) switchScene(targetKey);
      }
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    renderer.domElement.addEventListener('mousemove', e => updateHoverCursor(e.clientX, e.clientY));
    renderer.domElement.addEventListener('click', e => handleSelect(e.clientX, e.clientY));

    renderer.domElement.addEventListener('touchstart', e => {
      if (e.touches.length === 1) {
        const t = e.touches[0];
        updateHoverCursor(t.clientX, t.clientY);
      }
    }, { passive: true });

    (async function preloadAll() {
      const urls = Object.values(SCENES).map(s => s.image);
      await Promise.all(urls.map(u => loadTexture(u).catch(() => null)));
    })();

    document.getElementById('resetView').addEventListener('click', () => {
      controls.reset();
      controls.target.set(0, 0, 0);
      camera.position.set(0, 0, 0.1);
      controls.update();
    });
    document.getElementById('toggleLabels').addEventListener('click', () => {
      labelsVisible = !labelsVisible;
      setLabelsVisible(labelsVisible);
    });

    (async function init() {
      const blackTex = new THREE.DataTexture(new Uint8Array([0,0,0]), 1, 1);
      blackTex.needsUpdate = true;
      matA.map = blackTex; matA.needsUpdate = true; matA.opacity = 1;
      matB.opacity = 0;

      await switchScene(START_SCENE_KEY, { fadeMs: 400 });
      animate();
    })();
  </script>
</body>
</html>